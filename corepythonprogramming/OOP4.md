# 加法
## \_\_add\_\_

自定义加法运算时候用到，比如计算复数的加法，时间的计算

```python
def __add__(self,other):
	return self.__class__(self.hr+other.hr,self.min+other.min)
```
首先计算出个别的总数，然后调用类构造器返回一个新的对象

新的对象通过调用类来创建。在类中，一般不直接调用类名，而是使用`self`的属性`__class__`，这是一个更加面向对象的方法。如果类名改了那都要改。

## \_\_iadd\_\_
原位加法，就是支持+=的这种操作，覆盖原位。
**重载一个`__iadd__（）`方法的唯一秘密就是他必须放回self**

```python
def __iadd__(self,other):
	self.x += other.x
	self.y += other.y
	return self
	
```
可以用`id()`操作来确定一下，在原位加的前后，是不是修改了原来的对象！！

**其他运算也是类似**

---

# 迭代器
迭代器，可以一次一个的遍历序列。下面两个例子描述如何利用一个类中的`__iter__()`和`next()`方法，来创建一个迭代器。

第一个列子是，给类传入一个初始的序列，然后让用户通过`next()`去迭代。


# 新式类的高级特性

## \_\_slots\_\_
我的理解是，因为字典是很占内存的，当一个类实例化一些对象后，`__dict__`是用来跟踪所有的实例属性的，包括一些动态加入的，这样才有你半途`obj.x=1`类似与这样的属性加入进来，这一切都是保存在字典里面，但是有些类实例属性没那么多，但却有很多实例，这样就导致了字典使用效率很低，又占内存。为了解决这个问题，引进了`__slots__`，这个其实就有点类似C语言中的数组定长和动态分配。`__slots__`相当于数组长度一开始就是定好的，你规定了多少个实例属性，就只能用这些属性，不能动态增加了。



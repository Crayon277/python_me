>现实生活中的物体，运动起来总是按照某种规律的（去问问牛顿就知道了），而游戏中，有些动作就可以非常的不靠谱，比如吃豆人，大嘴巴永远以恒定的速度前进，可以瞬间转身或停止，要知道，这可是逆天的行为……现在的游戏中，制作者总是尽量的把运动做的和现实贴近（尤其是赛车游戏等），一辆车的运动，可能是上百种力同时作用的结果。不过幸好，我们只要知道一些基础的东西，很多运动和力的计算，都有现成的代码供我们使用。

# 理解帧率
FPS(Frame Per Second)是游戏和硬件间较量的永恒话题，

一般电视画面是24FPS，30FPS基本可以给玩家提供流畅的体验了，LCD的画，60FPS是常用的刷新率，所以你的游戏的帧率再高也没什么意义了；而绝大多数地球人都无法分辨70FPS以上的画面了

# 直线运动

程序见`move_directly.py`

应该要调节一下x，让鱼游得更自然一点，这个动画的帧率是多少？
在这个情形下，动画很简单，所以应该会很快，而有些时候动画元素很多，速度就会慢下来。这可不是我们想看到的。

# 关于时间
有一个解决上述问题的方法，就是让我们的动画基于时间运作，我们需要知道上一个画面到现在经过了多少时间，然后我们才能决定是否开始绘制下一副。
`pygame.time`模块给我们提供了一个`Clock`对象，是我们可以轻易做到这一些：
```python
clock = pygame.time.Clock()
time_passed = clock.tick()
time_passed = clock.tick(30)
```
第一行初始化了一个Clock对象，第二行的意思是返回一个上次调用的时间（以毫秒计算）;
**第三行非常有用**，在每一个循环中加上它，那么给`tick`方法加上的参数就成了游戏绘制的最大帧率，这样的画游戏就不会用掉你所有的cpu资源了。但是这仅仅是最大帧率，并不能代表用户看到的就是这个数字，有些时候机器性能不足，或者动画太复杂，实际的帧率达不到这个值，我们需要一种更有效的手段来控制我们的动画效果

为了使得在不同机器上有着一致的效果，我们其实是需要给定物体（我们把这个物体叫做精灵，Sprite)恒定的速度。这样的话，从起点到终点的时间点是一样的，最终的效果也就相同了，所差别的，只是流畅度。

![不同帧率](http://eyehere.net/wp-content/uploads/2011/06/pygame-fps.jpeg)
可以这么看，红星，蓝星都做一样的动作，从a点到b点，然后红星摄影师中间只拍一次呈现给大家看红星的运动轨迹，但是蓝星摄影师中间拍了3次，可能蓝星比较大牌，大家想看多一点她的镜头，然后呈现给大家。

假设让小鱼儿每秒游动250像素，这样游动一个屏幕差不多需要2.56秒（640/250），我们就需要知道，从上一帧开始到现在，小鱼应该游动了多少像素，这个算法很简单，速度*时间就行了，也就是250*time_passed_second。不过我们刚安嘎嘎得到的time_passed是毫秒，单位需要换算一下，不要忘了初一1000.0

程序见 `move_by_time.py`

**根据时间来计算运动的好处是不管你的集齐是更深的蓝还是打开个记事本都要后半天的淘汰机，人眼看起来，不同屏幕上的鱼的速度都是一致的了**
在很多情况下，通过时间控制要比直接调节帧率好用的多。
再强调一下为什么，因为速度是一样的，屏幕横向是640个像素是固定的，然后因为不同机器的刷新帧率不同，time_passed这个值不一样，这样导致的是不同机器，每次显示的位置是不一样，因为速度*时间，时间不一样么，但是起点，终点一样，又因为这差距人眼几乎识别不出来，就可以忽略不计了。

# 斜线运动

其实类似屏保，不再是单纯的直线运动，而是有点像屏保一样，触壁反弹。其实就是把速度取反

尤其是2D游戏，所谓的运动，只不过是把一个物体的坐标改一下而已，不过总是不停的计算和修改x和y，有点麻烦，
引入向量。--> 9
